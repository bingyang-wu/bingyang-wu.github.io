---
title: Java设计模式&单例
date: 2020-03-26 00:45:00
tags: 
	- Java
	- 设计模式
categories: Java
cover: https://raw.githubusercontent.com/bingyang-wu/imagebed/master/woman-sleeping-935777.jpg

---

## 单例

作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。

场景：

* Windows的任务管理器、回收站
* 项目中读取配置文件的类
* 网站的计数器
* 应用程序中的日志应用
* 数据库连接池，数据库连接是一种数据库资源
* 操作系统的文件系统，一个操作系统只能有一个文件系统
* Servlet中的Applicationydh对象
* Servlet中每个Servlet类也是单例的
* 再Spring中每个Bean默认是单例的，这样Spring容器可以管理
* Spring MVC 控制器对象也是单例的

优点：

​		由于单例模式中只产生一个实例，减少了系统性能开销，当一个对象的产生需要较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。



### 饿汉式

	* 优点：线程安全，调用效率高
	* 不能延时加载

```java
/**
 * 饿汉式单例
 *
 * @author milo
 */
public class SingletonHungry {

    /**
     * 类初始时立即加载(没有延时加载的优势)
     */
    private static SingletonHungry instance = new SingletonHungry();

    /**
     * 私有构造方法
     */
    private SingletonHungry() {

    }

    /**
     * 访问点
     */
    public static SingletonHungry getInstance() {
        return instance;
    }
}
```



### 懒汉式

* 优点：延时加载

* 缺点：调用效率低

```java
/**
 * 懒汉式单例
 *
 * @author milo
 */
public class SingletonLazy {

    /**
     * 类初始时不初始化这个对象，延时加载，用的时候再创建
     */
    private static SingletonLazy instance;

    /**
     * 私有构造方法
     */
    private SingletonLazy() {

    }

    /**
     * 方法同步,调用效率低
     */
    public static synchronized SingletonLazy getInstance() {
        if (instance == null) {
            instance = new SingletonLazy();
        }
        return instance;
    }
}
```



### 双重检测式

问题：由于编译器优化和JVM底层内部模型原因，指令重排时会出现问题，不建议使用。

```java
/**
 * 双重检测锁式
 *
 * @author milo
 */
public class SingletonDouble {
    private static SingletonDouble instance;

    private SingletonDouble() {

    }

    public static SingletonDouble getInstance() {
        if (instance == null) {
            SingletonDouble single;
            synchronized (SingletonDouble.class) {
                single = instance;
                if (single == null) {
                    synchronized (SingletonDouble.class) {
                        if (single == null) {
                            single = new SingletonDouble();
                        }
                    }
                    instance = single;
                }
            }

        }
        return instance;
    }
}

```



### 静态内部类

```java
/**
 * 静态内部类
 * 特点：
 * 外部类没有static属性，不会像饿汉式那样立即加载对象，延时加载
 * 只有真正调用getInstance才会加载静态内部类。加载类时是线程安全的
 * instance是static final类型，保证了内存中只有一个实例，而且只能被赋值一次，从而保证线程安全型。
 * 兼备了并发高效调用和延迟加载的优势
 *
 * @author milo
 */
public class SingletonInner {

    private SingletonInner() {
    }

    private static class Inner {
        private static final SingletonInner instance = new SingletonInner();
    }

    public static SingletonInner getInstance(){
        return Inner.instance;
    }
}
```



### 枚举

```java
/**
 * 枚举
 * 避免了反射和反序列化
 * 没有延时加载
 *
 * @author milo
 */
public enum SingletonEnum {
    /**
     * 枚举元素本身就是单例对象
     */
    INSTANCE;

    /**
     * 添加自己需要的操作
     */
    public void operation() {

    }
}
```



### 避免反射破解单例

```java
/**
 * 测试反射破解单例模式
 */
public class Client2 {
    public static void main(String[] args) throws ClassNotFoundException,
    NoSuchMethodException,
    IllegalAccessException, 
    InvocationTargetException, 
    InstantiationException {

       	Class<SingletonReflex> clazz = (Class<SingletonReflex>)Class.forName("com.secsmart.patterns.singleton.SingletonReflex");
        Constructor<SingletonReflex> c = clazz.getDeclaredConstructor(null);
        
        // 跳过权限检查
        c.setAccessible(true);
        SingletonReflex s3 = c.newInstance();
        SingletonReflex s4 = c.newInstance();
        System.out.println(s3 == s4);

    }
}
```



#### 解决办法

```java
/**
 * 懒汉式单例
 * 
 * @author milo
 */
public class SingletonReflex {

    /**
     * 类初始时不初始化这个对象，延时加载，用的时候再创建
     */
    private static SingletonReflex instance;

    /**
     * 私有构造方法
     */
    private SingletonReflex() {
        if (instance != null) {
            throw new RuntimeException("非法访问私有构造器");
        }
    }

    /**
     * 方法同步,调用效率低
     */
    public static synchronized SingletonReflex getInstance() {
        if (instance == null) {
            instance = new SingletonReflex();
        }
        return instance;
    }
}
```



### 避免序列化方式破解单例

```java
/**
 * 测试反序列化破解单例模式
 */
public class Test {
    public static void main(String[] args) throws IOException, ClassNotFoundException {

        SingletonReflex s1 = SingletonReflex.getInstance();
        SingletonReflex s2 = SingletonReflex.getInstance();

        // 通过反序列化的方式构造多个对象
        FileOutputStream fos = new FileOutputStream("d:/a.txt");
        ObjectOutput oos = new ObjectOutputStream(fos);
        oos.writeObject(s1);
        oos.close();
        fos.close();

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("d:/a.txt"));
        SingletonReflex s3 = (SingletonReflex) ois.readObject();
        ois.close();
        System.out.println(s1 == s2);

        System.out.println(s1 == s3);
        System.out.println(s2 == s3);
    }
}
```



#### 解决方法

```java
/**
 * 懒汉式单例
 *
 * @author milo
 */
public class SingletonReflex implements Serializable {

    /**
     * 类初始时不初始化这个对象，延时加载，用的时候再创建
     */
    private static SingletonReflex instance;

    /**
     * 私有构造方法
     */
    private SingletonReflex() {
        if (instance != null) {
            throw new RuntimeException("非法访问私有构造器");
        }
    }

    /**
     * 方法同步,调用效率低
     */
    public static synchronized SingletonReflex getInstance() {
        if (instance == null) {
            instance = new SingletonReflex();
        }
        return instance;
    }

    /**
     * 反序列化时,如果定义了readResolve方式则直接返回此方法指定的对象，而不需要单独创建新对象
     */
    private Object readResolve() {
        return instance;
    }

}
```



### 效率测试

```java
/**
 * 测试多线程环境下五种创建单例模式的效率
 */
public class Client4 {
    public static void main(String[] args) throws InterruptedException {

        long start = System.currentTimeMillis();

        CountDownLatch countDownLatch = new CountDownLatch(10000);

        for (int i = 0; i < 10000; i++) {

            new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 100000; i++) {
                        Object o = SingletonHungry.getInstance();
                    }

                    countDownLatch.countDown();
                }
            }).start();

        }

        countDownLatch.await();

        long end = System.currentTimeMillis();
        System.out.println((end - start) + "ms");
    }
}
```



#### 参考

| 类型       | 时间    |
| ---------- | ------- |
| 饿汉式     | 893ms   |
| 懒汉式     | 14409ms |
| 双重检查锁 | 932ms   |
| 静态内部类 | 859ms   |
| 枚举       | 880ms   |


#### 备注
在要保证单例的时候我们可以通过Spring容器来帮我们创建一个单例对象。